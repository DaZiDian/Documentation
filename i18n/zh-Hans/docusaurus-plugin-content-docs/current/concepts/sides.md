# 游戏两侧的区分

和许多其他程序一样，Minecraft 遵循客户端-服务器的概念，其中客户端负责显示数据，而服务器负责更新数据。当我们使用这些术语时，我们对其含义有一个相当直观的理解...对吗？

事实证明，并非如此。很多混淆源于 Minecraft 有两种不同的“侧”的概念，这取决于上下文：物理侧和逻辑侧。

## 逻辑侧与物理侧

### 物理侧

当你打开 Minecraft 启动器，选择一个 Minecraft 安装并按下播放时，你启动了一个**物理客户端**。这里使用“物理”一词是在“这是一个客户端程序”的意义上。这尤其意味着客户端功能，如所有渲染相关的功能，都可以在这里使用。相比之下，**物理服务器**，也称为专用服务器，是在你启动一个 Minecraft 服务器 JAR 时打开的。虽然 Minecraft 服务器带有一个基本的 GUI，但它缺少所有仅限客户端的功能。最值得注意的是，各种客户端类在服务器 JAR 中缺失。在物理服务器上调用这些类将导致缺少类错误，即崩溃，因此我们需要对此进行防护。

### 逻辑侧

逻辑侧主要关注 Minecraft 的内部程序结构。**逻辑服务器**是游戏逻辑运行的地方。如时间和天气变化、实体更新、实体生成等都在服务器上运行。所有种类的数据，如库存内容，也都是服务器的责任。另一方面，**逻辑客户端**负责显示所有需要显示的内容。Minecraft 在一个名为 `net.minecraft.client` 的独立包中保留了所有客户端代码，并在一个名为渲染线程的独立线程中运行它，而其他所有内容都被视为公共代码（即客户端和服务器代码）。

### 两者有何区别？

物理侧和逻辑侧之间的区别最好通过两种情况来说明：

- 玩家加入一个**多人游戏**世界。这相当直接：玩家的物理（和逻辑）客户端连接到别处的一个物理（和逻辑）服务器——玩家不关心在哪里；只要他们能连接，这就是所有客户端知道的，也是所有客户端需要知道的。
- 玩家加入一个**单人游戏**世界。这里的情况变得有趣。玩家的物理客户端启动了一个逻辑服务器，然后现在作为逻辑客户端，连接到同一台机器上的那个逻辑服务器。如果你熟悉网络，你可以把它想象为连接到`localhost`（只是概念上的；没有实际的套接字或类似的东西涉及）。

这两种情况也显示了主要问题：如果一个逻辑服务器可以使用你的代码，这并不保证物理服务器也能同样使用。这就是为什么你应该始终使用专用服务器进行测试，以检查意外行为。由于客户端和服务器分离不当导致的`NoClassDefFoundError`和`ClassNotFoundException`是模组制作中最常见的错误之一。另一个常见的错误是使用静态字段，并从两个逻辑侧访问它们；这特别棘手，因为通常没有迹象表明有什么问题。

:::tip
如果你需要将数据从一侧传输到另一侧，你必须[发送一个数据包

][networking]。
:::

在 NeoForge 代码库中，物理侧由一个名为 `Dist` 的枚举表示，而逻辑侧由一个名为 `LogicalSide` 的枚举表示。

:::info
从历史上看，服务器 JAR 拥有客户端没有的类。在现代版本中，这种情况已不复存在；如果愿意，可以认为物理服务器是物理客户端的一个子集。
:::

## 执行侧特定操作

### `Level#isClientSide()`

这个布尔检查将是你最常用的检查侧的方式。在 `Level` 对象上查询此字段可以确定级别所属的**逻辑**侧：如果此字段为 `true`，则级别在逻辑客户端上运行。如果字段为 `false`，则级别在逻辑服务器上运行。据此，物理服务器将始终在此字段中包含 `false`，但我们不能假设 `false` 暗示物理服务器，因为此字段也可能在物理客户端内的逻辑服务器（即单人游戏世界）中为 `false`。

只有在需要确定是否运行游戏逻辑和其他机制时才使用此检查。例如，如果你想在玩家每次点击你的方块时对玩家造成伤害，或者让你的机器将泥土处理成钻石，你应该确保 `#isClientSide` 为 `false` 后再进行。在逻辑客户端应用游戏逻辑可能导致最好的情况下出现数据不同步（幽灵实体、不同步的统计数据等），在最坏的情况下导致崩溃。

:::tip
这个检查应该作为你的默认选择。每当你有一个 `Level` 可用时，就使用这个检查。
:::

### `FMLEnvironment.dist`

`FMLEnvironment.dist` 是 `Level#isClientSide()` 检查的**物理**对应项。如果此字段为 `Dist.CLIENT`，你就在物理客户端上。如果字段为 `Dist.SERVER`，你就在物理服务器上。

检查物理环境在处理仅限客户端的类时非常重要。所有对客户端代码的调用都应始终包含在对 `Dist.CLIENT` 的检查中，并然后调用一个单独的类以防止意外的类加载：

```java
public class SomeCommonClass {
    public void someCommonMethod() {
        // 仅当你在物理客户端上时，SomeClientClass 才会被加载
        if (FMLEnvironment.dist == Dist.CLIENT) {
            SomeClientClass.someClientMethod();
        }
    }
}

public class SomeClientClass {
    public static void someClientMethod() {
        Minecraft.getInstance().whatever();
    }
}
```

:::tip
通常期望模组在任一侧都能工作。这特别意味着，如果你正在开发一个仅限客户端的模组，你应该验证该模组实际上在物理客户端上运行，并且在不运行的情况下无操作。
:::

[networking]: ../networking/index.md
