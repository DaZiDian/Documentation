import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

ForgeGradle 配置
==========================

ForgeGradle 提供了众多配置选项，以便改变开发环境的配置方式。大部分的配置通过 `minecraft` 代码块设置，但一些其他配置可以在 `dependencies` 代码块内指定，或修改构建的 `jar`，例如 `reobfJar`。

启用 Access Transformer
----------------------------

[Access Transformer][at]可以扩大 Minecraft 类、方法和字段的可见性或修改它们的 `final` 标志。

<Tabs defaultValue="latest">
<TabItem value="latest" label="最新">
要在开发环境中启用 Access Transformer ，您可以在 `minecraft` 代码块中设置 `accessTransformers` 到相关的配置文件：

```gradle
minecraft {
    // ...

    // 添加一个AT文件，相对于项目目录
    accessTransformers {
        file('src/main/resources/META-INF/accesstransformer.cfg')

        // 可以指定多个文件，按顺序应用
        file('src/main/resources/accesstransformer_extras.cfg')
    }
}
```

在开发环境中，NeoForge 会根据 `mods.toml` 中指定的搜索AT文件，或者在没有指定的情况下搜索 `META-INF/accesstransformer.cfg`:

```toml
[[accessTransformers]]
file="META-INF/accesstransformer.cfg"

[[accessTransformers]]
file="accesstransformer_extras.cfg"
```

</TabItem>


<TabItem value="7.0.40" label="7.0.40 及早期版本">
要在开发环境中启用AT，您可以将 `accessTransformer` 设置到相关配置文件：

```gradle
minecraft {
    // ...

    // 添加一个AT文件，相对于项目目录
    accessTransformer = project.file('src/main/resources/META-INF/accesstransformer.cfg')
}
```

:::caution
虽然在开发环境中的AT可以从用户指定的任何位置读取，在开发环境中，文件只能从 `META-INF/accesstransformer.cfg` 读取。
:::
</TabItem>
</Tabs>

人类可读映射
-----------------------

Minecraft 的源代码是混淆的。因此，所有的类、方法和字段都有机器生成的名称，没有包结构。与此同时，函数本地变量名称被转换为雪人（`☃`），因为本地变量表的存储方式。使用这些混淆名称创建模组非常困难，因为给它们做逆向工程既繁琐，又可能在版本之间发生变化，且可能在语言本身中无效，但在字节码中有效。

为了解决这最后两个问题，Forge 通过 [ForgeAutoRenamingTool][fart] (Forge 自动重命名工具)，模糊地将每个类、方法、字段和参数映射到一个唯一的标识符，即 SRG 名称。当用户客户端运行游戏时，会使用 SRG 映射。

为了简化开发，ForgeGradle 允许用户选择一个映射集来应用在 SRG 映射之上，我们将其称为人类可读映射。ForgeGradle 知道如何通过 `reobf*` 任务将模组 jar 转换为 SRG 映射，以便在生产中使用。

可以通过在 `minecraft` 块中设置 `mappings` 字段来指定所使用的映射集。`mappings` 字段接受两个参数：`channel` 是映射集的类型，而 `version` 是要应用的映射集的版本。

目前，ForgeGradle 内置了三套默认的映射集：

* `official` - 使用 Mojang 提供的映射集。这些映射没有参数名称，只从 1.14 版本开始存在。
* `stable` - 使用由 MCP 生成的映射集。这些通常不完整，并且从 1.17 版本开始就不再存在。
* `snapshot` - 这也是 MCP 生成的映射集，类似于程序的每日版构建。这些也通常不完整，并从 1.17 版本开始就不再存在。

:::info
生产中使用的类名称来自 1.17 版本之前的 `stable` 映射集，从 1.17 版本开始则来自 `official` 映射集。
:::

```gradle
mappings {
    // 设置映射 使用 Mojang 提供的 Minecraft 1.19.4 版本映射。
    mappings channel: 'official', version: '1.19.4'

    // ...
}
```

### Parchment

Parchment 是 ParchmentMC 维护的官方项目，它在 `official` 映射集之上提供了开放的、社区来源的参数名称和 javadocs。你可以在[它们的网站][parchment]上了解如何设置和使用 Parchment 映射集。

准备运行任务
-------------------

运行任务（`run*`）有两个独立的处理流程，这取决于它们是通过 `gradlew` 还是通过运行配置执行的。默认情况下，有两个任务负责准备工作区以执行游戏：

首先，有 `prepare*` 任务，这些任务在 `run*` 任务之前执行，以确保游戏的映射文件已准备好。`prepare*Compile` 任务通常只作为 `run*` 任务的依赖项执行，以确保在运行游戏之前先将游戏编译好。

如果你使用的 IDE 是 Eclipse 或 IntelliJ IDEA，可以通过分别将 `enableEclipsePrepareRuns` 或 `enableIdeaPrepareRuns` 设置为 `true` 来配置运行配置，在启动游戏之前执行 `prepare*` 任务。这将允许你在 IDE 启动游戏之前调用自定义的 Gradle 任务。

```gradle
minecraft {
    // ...

    // 启用运行配置的 'prepare*' 任务
    enableEclipsePrepareRuns true
    enableIdeaPrepareRuns true
}
```

### 复制 IDE 资源

`copyIdeResources` 属性可以用来将 `processResources` 任务配置的资源复制到 IDE 的资源输出目录。这允许不调用 Gradle 的 IDE 运行配置（配置为使用 IDEA 运行器的 IntelliJ 或 Eclipse）使用由构建脚本配置的资源。通常，在你需要在像 `mods.toml` 这样的文件中替换值时，你需要启用这个属性。
这只适用于通过 `copyEclipseResources` 任务和 `copyIntellijResources` 任务，分别应用于 Eclipse 和 IntelliJ IDEA。

```gradle
minecraft {
    // ...

    // 从 'processResources' 任务复制文件到 IDE 的资源输出目录
    copyIdeResources true
}
```

### 运行配置文件夹

如果将 `generateRunFolders` 设置为 `true`，则可以将运行配置排序到文件夹中。这会读取特定 [运行配置][run] 中设置的 `folderName` 属性来确定组织结构
```gradle
minecraft {
    // ...

    // 当设置为 true 时，运行配置将根据它们的 'folderName' 被分组到文件夹中
    generateRunFolders true
}
```

[at]: https://docs.minecraftforge.net/en/latest/advanced/accesstransformers/
[fart]: https://github.com/MinecraftForge/ForgeAutoRenamingTool
[parchment]: https://parchmentmc.org/docs/getting-started
[run]: ./runs.md#run-configurations
